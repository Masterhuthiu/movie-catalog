= PART I:
= Movie Catalog Microservice
:toc:
:toclevels: 2

The *Movie Catalog Microservice* is built on **Spring Boot 3** and **JHipster 8**, optimized for a modern *Microservices architecture*.

== üöÄ Project Overview

This service acts as a **core component** in a Microservices ecosystem, responsible for managing movie data sourced from the `sample_mflix` collection on **MongoDB Atlas**.
It is designed with **enterprise-grade standards** in mind.

=== Key Features

- *Movie Management*:
Full CRUD operations with **Partial Update (PATCH)** support for efficient data updates.

- *Service Discovery*:
Dynamic service registration and lookup using **Consul**.

- *Database Migration*:
Automated schema versioning and migration powered by **Mongock**.

- *Observability*:
Integrated **Prometheus metrics** and **Zipkin distributed tracing** for performance monitoring and diagnostics.

- *Resilience*:
Uses **Feign Client** with **Circuit Breaker patterns** to prevent cascading failures in distributed systems.

---

== üõ† Tech Stack

[cols="1,2"]
|===
| Component | Technology

| Framework
| Spring Boot 3.x, JHipster 8

| Language
| Java 17

| Database
| MongoDB Atlas (Cloud NoSQL) / MongooDB local(podman/docker)

| Service Discovery
| Spring Cloud Consul

| Monitoring
| Micrometer, Prometheus, Grafana

| Security
| OAuth2, JWT
|===

---

== üèó System Architecture

The service operates as a **stateless component** connecting directly to a **MongoDB Atlas cluster**.

- *Web Layer*:
REST Controllers exposing APIs to external clients.

- *Service Layer*:
`MovieService` encapsulates business logic and optimized object mapping.

- *Data Layer*:
`MovieRepository` extends `MongoRepository` for seamless interaction with MongoDB Atlas.

---

== ‚öôÔ∏è Configuration and Setup

=== 1. System Requirements

- Java 17+
- Docker (for running Consul and Zipkin locally)

Start infrastructure services:

[source,bash]
----
docker compose -f src/main/docker/consul.yml up
Or
podman compose -f src/main/docker/consul.yml up
----

---

=== 2. Critical Environment Variables

Development configuration is defined in `application-dev.yml`.

Key settings include:

- *MongoDB URI*:
Connection string to **Cluster0** on MongoDB Atlas.

- *Server Port*:
`8081`

- *JWT Secret*:
Base64-encoded secret for enhanced authentication security.

---

=== 3. Run the Application

[source,bash]
----
./mvnw
----

---

== üìä Monitoring and API Documentation

- *Health Check Endpoint*:
http://localhost:8081/management/health

This endpoint verifies:

- Application status
- Database connectivity
- Overall service health

---

== üí° Technical Highlights & Problem Solving

During development, several technical challenges were addressed:

- *Hazelcast vs DevTools Conflict*:
Disabled Spring DevTools automatic restart to avoid conflicts with **Hazelcast caching**.

- *Fluent API Domain Model*:
Implemented a **Fluent API style** for domain objects, improving unit testing readability and object construction.

- *CORS & Security Hardening*:
Configured a strict **Content Security Policy (CSP)** to mitigate **XSS (Cross-Site Scripting)** vulnerabilities.

---

== üìå Summary

This microservice demonstrates:

- Production-ready **Spring Boot microservice design**
- Secure **OAuth2/JWT authentication**
- Cloud-native **MongoDB Atlas integration**
- Full **observability and resilience patterns**
- Compatibility with **Docker, Kubernetes, and OpenShift**

‚û°Ô∏è Suitable as a **backend portfolio project** for *Java Backend / Microservices / Cloud / DevOps roles*.

= PART II: Cloud-Native Orchestration & CI/CD

== ‚ò∏Ô∏è Kubernetes & OpenShift (MicroShift) Deployment

Beyond local containers, this service is fully architected for **Cloud-Native orchestration**, optimized for resource-constrained environments like **MicroShift**.

=== 1. Containerization & Image Strategy
The application is packaged as a lightweight, OCI-compliant image using a daemonless build approach.

* **Advanced Build Tooling**: 
Leverages **Google Jib** to build optimized image layers tr·ª±c ti·∫øp t·ª´ Maven, bypassing the need for a Docker daemon and reducing the attack surface.
* **Registry Management**: 
Hosted on **Quay.io** with integrated **Clair security scanning** to ensure all production layers are free of critical vulnerabilities.

=== 2. Infrastructure as Code (IaC) - K8s Manifests
I developed custom Kubernetes manifests to manage the deployment lifecycle with a focus on stability and configuration decoupling.

* **Deployment Strategy**: 
Utilizes `RollingUpdate` to ensure zero-downtime deployments.
* **Environment Injection**: 
Decouples infrastructure from code by injecting critical variables via K8s Environment Variables.
* **Resource Constraints**: 
Defined CPU/Memory requests and limits to ensure cluster stability.

[source,yaml]
----
# Example Backend Environment Configuration
containers:
  - name: movie-app
    image: quay.io/cosa199212/movie-catalog-service:latest
    env:
      - name: SPRING_DATA_MONGODB_URI
        value: "mongodb://mongodb:27017/sample_mflix"
      - name: SPRING_CLOUD_CONSUL_HOST
        value: "consul"
----

=== 3. High-Volume Data Provisioning (23K+ Documents)
A standout technical achievement was the successful management of a large-scale dataset within a containerized environment.

* **Image-Layer Persistence**: 
Utilized a pre-seeded MongoDB image (`mongodb-full-data`) containing the **sample_mflix** dataset with **23,539+ documents**.
* **Volume Masking Resolution**: 
Identified and resolved a conflict where K8s default volume mounts overrode internal image data. By bypassing external mounts for this specific dev-tier, I achieved **instant-ready data availability**.
* **Complex Data Mapping**: 
Successfully mapped nested NoSQL structures (e.g., `imdb.rating`, `imdb.votes`) to Java objects using Spring Data `@Field` annotations.



=== 4. Automated CI/CD Pipeline (GitHub Actions)
Implemented a fully automated pipeline to streamline the transition from code to production.

* **Continuous Integration**: 
Automated Maven builds and unit testing on every `push` or `pull_request`.
* **Continuous Deployment**: 
Seamlessly pushes verified OCI images to Quay.io using GitHub Secrets for secure authentication.

[source,yaml]
----
# .github/workflows/main.yml
name: Movie Catalog CI/CD
on: [push]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
      - name: Build & Push to Quay.io
        run: |
          ./mvnw -Pprod verify jib:build \
            -Djib.to.image=quay.io/cosa199212/movie-catalog-service:latest \
            -Djib.to.auth.username=${{ secrets.QUAY_USERNAME }} \
            -Djib.to.auth.password=${{ secrets.QUAY_PASSWORD }}
----



=== 5. Cluster Observability & Troubleshooting
Expertise in maintaining system health through advanced CLI tooling:

* **Internal Inspection**: 
Used `oc debug` to verify the **WiredTiger** storage engine paths inside the running Pod.
* **Streamed Data Injection**: 
Mastered the use of PowerShell pipes to perform large-scale JSON imports into the cluster:
+
[source,powershell]
----
Get-Content movies.json -Raw | oc exec -i <pod-name> -- mongoimport --jsonArray
----
* **Service Discovery**: 
Integrated with **Consul** for dynamic service lookups and health monitoring.

---

== üìå Technical Summary
This project demonstrates a transition from a simple Spring Boot app to a **full-scale Cloud-Native solution**. It showcases proficiency in:

* **Java Microservices**: Spring Boot 3, JHipster 8
* **NoSQL Architecture**: MongoDB Atlas & Local Optimization
* **DevOps Patterns**: CI/CD, GitHub Actions, Quay.io
* **Cloud Orchestration**: Kubernetes/OpenShift (MicroShift) CLI, Manifest management